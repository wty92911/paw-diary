// @ts-nocheck - Block type system refactor in progress
import React from 'react';
import { type Control, type FieldError } from 'react-hook-form';
import { Input } from '../../ui/input';
import { Button } from '../../ui/button';
import { Badge } from '../../ui/badge';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '../../ui/select';
import { Calendar, Clock, Bell, Repeat } from 'lucide-react';
import { type ActivityFormData, type ActivityBlockDef } from '../../../lib/types/activities';
import { Field } from './Field';
import { useFormContext } from './FormContext';

// Reminder value interface
interface ReminderValue {
  title: string;
  reminderDate: Date;
  reminderTime: string; // HH:MM format
  isEnabled: boolean;
  recurrence?: RecurrencePattern;
  notificationMethods: NotificationMethod[];
  notes?: string;
}

// Recurrence pattern interface
interface RecurrencePattern {
  type: 'daily' | 'weekly' | 'monthly' | 'yearly' | 'custom';
  interval: number; // Every X days/weeks/months/years
  daysOfWeek?: number[]; // For weekly: 0-6 (Sun-Sat)
  dayOfMonth?: number; // For monthly: 1-31
  endDate?: Date; // When to stop recurring
  endAfterOccurrences?: number; // Stop after X occurrences
}

// Notification method interface
interface NotificationMethod {
  type: 'push' | 'email' | 'sms';
  enabled: boolean;
  minutesBefore?: number; // How many minutes before to notify
}

// Predefined reminder types for pets
const REMINDER_TYPES = {
  medical: {
    label: 'Medical',
    icon: 'üè•',
    templates: [
      'Vet Checkup',
      'Vaccination Due',
      'Medication Time',
      'Flea/Tick Treatment',
      'Heartworm Prevention',
      'Dental Cleaning',
    ],
  },
  grooming: {
    label: 'Grooming',
    icon: '‚úÇÔ∏è',
    templates: [
      'Nail Trim',
      'Bath Time',
      'Professional Grooming',
      'Ear Cleaning',
      'Brushing',
    ],
  },
  feeding: {
    label: 'Feeding',
    icon: 'üçΩÔ∏è',
    templates: [
      'Meal Time',
      'Treat Time',
      'Water Refill',
      'Special Diet',
    ],
  },
  activity: {
    label: 'Activity',
    icon: 'üéæ',
    templates: [
      'Walk Time',
      'Exercise',
      'Training Session',
      'Playtime',
    ],
  },
  general: {
    label: 'General',
    icon: 'üìã',
    templates: [
      'Custom Reminder',
      'Important Note',
      'Follow-up',
    ],
  },
} as const;

// Quick time presets
const TIME_PRESETS = [
  { label: 'Morning', time: '08:00' },
  { label: 'Noon', time: '12:00' },
  { label: 'Evening', time: '18:00' },
  { label: 'Night', time: '21:00' },
];

// Reminder block specific props
interface ReminderBlockProps {
  block: ActivityBlockDef & { type: 'reminder' };
  control?: Control<ActivityFormData>;
  error?: FieldError;
}

// ReminderBlock component for setting activity reminders with recurrence
const ReminderBlock: React.FC<ReminderBlockProps> = ({
  block,
  error,
}) => {
  const { watch, setValue } = useFormContext();
  const fieldName = `blocks.${block.id}` as const;
  const currentValue: ReminderValue | undefined = watch(fieldName);

  // State management
  const [showRecurrence, setShowRecurrence] = React.useState(false);
  const [showNotifications, setShowNotifications] = React.useState(false);

  // Initialize default value
  React.useEffect(() => {
    if (!currentValue) {
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      
      setValue(fieldName, {
        title: '',
        reminderDate: tomorrow,
        reminderTime: '09:00',
        isEnabled: true,
        notificationMethods: [
          { type: 'push', enabled: true, minutesBefore: 15 },
        ],
      });
    }
  }, [currentValue, fieldName, setValue]);

  // Handle basic field changes
  const handleFieldChange = React.useCallback((field: keyof ReminderValue, value: string | boolean | NotificationMethod[]) => {
    const updatedValue: ReminderValue = {
      ...currentValue!,
      [field]: value,
    };
    setValue(fieldName, updatedValue);
  }, [currentValue, fieldName, setValue]);

  // Handle recurrence pattern changes
  const handleRecurrenceChange = React.useCallback((recurrence: RecurrencePattern | undefined) => {
    const updatedValue: ReminderValue = {
      ...currentValue!,
      recurrence,
    };
    setValue(fieldName, updatedValue);
  }, [currentValue, fieldName, setValue]);

  // Handle notification method changes
  const handleNotificationChange = React.useCallback((methods: NotificationMethod[]) => {
    const updatedValue: ReminderValue = {
      ...currentValue!,
      notificationMethods: methods,
    };
    setValue(fieldName, updatedValue);
  }, [currentValue, fieldName, setValue]);

  // Quick template selection
  const handleTemplateSelect = React.useCallback((template: string) => {
    handleFieldChange('title', template);
  }, [handleFieldChange]);

  // Quick time preset
  const handleTimePreset = React.useCallback((time: string) => {
    handleFieldChange('reminderTime', time);
  }, [handleFieldChange]);

  // Format date for display
  const formatDate = (date: Date): string => {
    return new Intl.DateTimeFormat('en-US', {
      weekday: 'short',
      month: 'short',
      day: 'numeric',
      year: 'numeric',
    }).format(date);
  };

  // Format datetime for input
  const formatDateForInput = (date: Date): string => {
    return date.toISOString().split('T')[0];
  };

  // Parse date from input
  const parseDateFromInput = (dateString: string): Date => {
    return new Date(dateString + 'T00:00:00');
  };

  // Get recurrence description
  const getRecurrenceDescription = (pattern: RecurrencePattern): string => {
    switch (pattern.type) {
      case 'daily':
        return pattern.interval === 1 ? 'Daily' : `Every ${pattern.interval} days`;
      case 'weekly':
        return pattern.interval === 1 ? 'Weekly' : `Every ${pattern.interval} weeks`;
      case 'monthly':
        return pattern.interval === 1 ? 'Monthly' : `Every ${pattern.interval} months`;
      case 'yearly':
        return pattern.interval === 1 ? 'Yearly' : `Every ${pattern.interval} years`;
      default:
        return 'Custom recurrence';
    }
  };

  if (!currentValue) return null;

  return (
    <Field
      label={block.label}
      required={block.required}
      error={error?.message}
      hint={block.config?.hint || 'Set up a reminder for future activities or follow-ups'}
      blockType="reminder"
      id={`reminder-${block.id}`}
    >
      <div className="space-y-4">
        {/* Reminder enabled toggle */}
        <div className="flex items-center justify-between">
          <label className="text-sm font-medium">Reminder</label>
          <div className="flex items-center gap-2">
            <input
              type="checkbox"
              checked={currentValue.isEnabled}
              onChange={(e) => handleFieldChange('isEnabled', e.target.checked)}
              className="rounded"
            />
            <span className="text-sm text-muted-foreground">
              {currentValue.isEnabled ? 'Enabled' : 'Disabled'}
            </span>
          </div>
        </div>

        {/* Reminder content - only show if enabled */}
        {currentValue.isEnabled && (
          <>
            {/* Quick templates */}
            <div className="space-y-2">
              <label className="text-sm font-medium">Quick Templates</label>
              <div className="grid grid-cols-2 gap-2">
                {Object.entries(REMINDER_TYPES).map(([key, type]) => (
                  <Select key={key} onValueChange={handleTemplateSelect}>
                    <SelectTrigger className="text-xs">
                      <SelectValue placeholder={`${type.icon} ${type.label}`} />
                    </SelectTrigger>
                    <SelectContent>
                      {type.templates.map((template) => (
                        <SelectItem key={template} value={template}>
                          {template}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                ))}
              </div>
            </div>

            {/* Reminder title */}
            <div>
              <label className="text-sm font-medium">Reminder Title</label>
              <Input
                type="text"
                placeholder="What do you want to be reminded about?"
                value={currentValue.title}
                onChange={(e) => handleFieldChange('title', e.target.value)}
                className="mt-1"
              />
            </div>

            {/* Date and time */}
            <div className="grid grid-cols-2 gap-3">
              <div>
                <label className="text-sm font-medium flex items-center gap-1">
                  <Calendar className="w-3 h-3" />
                  Date
                </label>
                <Input
                  type="date"
                  value={formatDateForInput(currentValue.reminderDate)}
                  onChange={(e) => handleFieldChange('reminderDate', parseDateFromInput(e.target.value))}
                  className="mt-1"
                />
              </div>
              <div>
                <label className="text-sm font-medium flex items-center gap-1">
                  <Clock className="w-3 h-3" />
                  Time
                </label>
                <div className="mt-1 space-y-2">
                  <Input
                    type="time"
                    value={currentValue.reminderTime}
                    onChange={(e) => handleFieldChange('reminderTime', e.target.value)}
                  />
                  <div className="flex gap-1">
                    {TIME_PRESETS.map((preset) => (
                      <Button
                        key={preset.time}
                        type="button"
                        variant="outline"
                        size="sm"
                        onClick={() => handleTimePreset(preset.time)}
                        className={`text-xs ${
                          currentValue.reminderTime === preset.time ? 'bg-primary/10' : ''
                        }`}
                      >
                        {preset.label}
                      </Button>
                    ))}
                  </div>
                </div>
              </div>
            </div>

            {/* Reminder preview */}
            <div className="bg-primary/5 border border-primary/20 rounded-md p-3">
              <div className="flex items-center gap-2">
                <Bell className="w-4 h-4 text-primary" />
                <div className="flex-1">
                  <div className="font-medium text-sm">
                    {currentValue.title || 'Untitled Reminder'}
                  </div>
                  <div className="text-xs text-muted-foreground">
                    {formatDate(currentValue.reminderDate)} at {currentValue.reminderTime}
                  </div>
                </div>
                {currentValue.recurrence && (
                  <Badge variant="secondary" className="text-xs">
                    <Repeat className="w-3 h-3 mr-1" />
                    {getRecurrenceDescription(currentValue.recurrence)}
                  </Badge>
                )}
              </div>
            </div>

            {/* Advanced options */}
            <div className="space-y-3 border-t pt-3">
              <div className="flex gap-2">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setShowRecurrence(!showRecurrence)}
                  className="text-xs"
                >
                  <Repeat className="w-3 h-3 mr-1" />
                  {currentValue.recurrence ? 'Edit Repeat' : 'Add Repeat'}
                </Button>
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => setShowNotifications(!showNotifications)}
                  className="text-xs"
                >
                  <Bell className="w-3 h-3 mr-1" />
                  Notifications
                </Button>
              </div>

              {/* Recurrence options */}
              {showRecurrence && (
                <div className="space-y-3 p-3 border rounded-md bg-muted/30">
                  <div className="text-sm font-medium">Repeat Pattern</div>
                  
                  <div className="grid grid-cols-2 gap-2">
                    <Select
                      value={currentValue.recurrence?.type || 'daily'}
                      onValueChange={(type) => {
                        const newRecurrence: RecurrencePattern = {
                          type: type as RecurrencePattern['type'],
                          interval: currentValue.recurrence?.interval || 1,
                        };
                        handleRecurrenceChange(newRecurrence);
                      }}
                    >
                      <SelectTrigger>
                        <SelectValue />
                      </SelectTrigger>
                      <SelectContent>
                        <SelectItem value="daily">Daily</SelectItem>
                        <SelectItem value="weekly">Weekly</SelectItem>
                        <SelectItem value="monthly">Monthly</SelectItem>
                        <SelectItem value="yearly">Yearly</SelectItem>
                      </SelectContent>
                    </Select>

                    <div className="flex items-center gap-1">
                      <span className="text-xs">Every</span>
                      <Input
                        type="number"
                        min={1}
                        max={99}
                        value={currentValue.recurrence?.interval || 1}
                        onChange={(e) => {
                          if (currentValue.recurrence) {
                            handleRecurrenceChange({
                              ...currentValue.recurrence,
                              interval: parseInt(e.target.value) || 1,
                            });
                          }
                        }}
                        className="text-xs text-center"
                      />
                    </div>
                  </div>

                  <div className="flex justify-between">
                    <Button
                      type="button"
                      variant="ghost"
                      size="sm"
                      onClick={() => handleRecurrenceChange(undefined)}
                      className="text-xs text-muted-foreground"
                    >
                      Remove Repeat
                    </Button>
                    <Button
                      type="button"
                      variant="outline"
                      size="sm"
                      onClick={() => setShowRecurrence(false)}
                      className="text-xs"
                    >
                      Done
                    </Button>
                  </div>
                </div>
              )}

              {/* Notification options */}
              {showNotifications && (
                <div className="space-y-3 p-3 border rounded-md bg-muted/30">
                  <div className="text-sm font-medium">Notification Settings</div>
                  
                  {currentValue.notificationMethods.map((method, index) => (
                    <div key={index} className="flex items-center justify-between">
                      <div className="flex items-center gap-2">
                        <input
                          type="checkbox"
                          checked={method.enabled}
                          onChange={(e) => {
                            const updatedMethods = [...currentValue.notificationMethods];
                            updatedMethods[index].enabled = e.target.checked;
                            handleNotificationChange(updatedMethods);
                          }}
                          className="rounded"
                        />
                        <span className="text-sm capitalize">{method.type}</span>
                        {method.minutesBefore && (
                          <Badge variant="outline" className="text-xs">
                            {method.minutesBefore}m before
                          </Badge>
                        )}
                      </div>
                    </div>
                  ))}

                  <Button
                    type="button"
                    variant="outline"
                    size="sm"
                    onClick={() => setShowNotifications(false)}
                    className="text-xs w-full"
                  >
                    Done
                  </Button>
                </div>
              )}
            </div>

            {/* Notes */}
            <div>
              <label className="text-sm font-medium">Additional Notes (Optional)</label>
              <Input
                type="text"
                placeholder="Any extra details for this reminder..."
                value={currentValue.notes || ''}
                onChange={(e) => handleFieldChange('notes', e.target.value)}
                className="mt-1"
              />
            </div>
          </>
        )}
      </div>
    </Field>
  );
};

export default ReminderBlock;